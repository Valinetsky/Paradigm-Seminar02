# Императивное и декларативное программирование на практике. Семинар 02

## Задача №1
__Условие__

На вход подается число n.

__Задача__

Написать скрипт в любой парадигме, который выводит на экран таблицу умножения всех чисел от 1 до n.
Обоснуйте выбор парадигм.

Пример вывода:
||
|-|
|1 * 1 = 1|
|1 * 2 = 2|
|1 * 3 = 3|
|1 * 4 = 4|
|1 * 5 = 5|
|1 * 6 = 6|
|…|
|1 * 9 = 9|


## Задача №2

Переписать алгоритм в процедурном стиле

Определение функции merge_sort, которая выполняет сортировку методом слияния.

```python
def merge_sort(arr):
	if len(arr) > 1: # Проверка, что длина массива больше 1 (иначе сортировка не нужна).
		mid = len(arr) // 2 # Вычисление середины массива.
		left_half = arr[:mid] # Создание левой половины массива.
		right_half = arr[mid:] # Создание правой половины массива.

		# Рекурсивный вызов merge_sort для левой и правой половин массива.
		merge_sort(left_half)
		merge_sort(right_half)

		i = j = k = 0  # Инициализация индексов для объединения двух половин.
	
		# Объединение левой и правой половин в один отсортированный массив.
		while i < len(left_half) and j < len(right_half):
			if left_half[i] < right_half[j]:  # Сравнение элементов левой и правой половин.
				arr[k] = left_half[i]  # Если элемент из левой меньше, помещаем его в исходный массив.
				i += 1
			else:
				arr[k] = right_half[j]  # Если элемент из правой меньше, помещаем его в исходный массив.
				j += 1
			k += 1
	
		# Добавление оставшихся элементов из левой и правой половин (если такие есть).
		while i < len(left_half):
			arr[k] = left_half[i]
			i += 1
			k += 1
	
		while j < len(right_half):
			arr[k] = right_half[j]
			j += 1
			k += 1
        
my_array = [64, 34, 25, 12, 22, 11, 90] # Создание неотсортированного массива.
merge_sort(my_array) # Вызов функции сортировки слиянием.
print("Отсортированный массив (Merge Sort):", my_array) # Вывод отсортированного массива.
```

В исходном коде есть блок:

```python
# Добавление оставшихся элементов из левой и правой половин (если такие есть).
while i < len(left_half):
	arr[k] = left_half[i]
	i += 1
	k += 1

while j < len(right_half):
	arr[k] = right_half[j]
	j += 1
	k += 1
```

Его можно подсушить (DRY) в одну функцию:

```python
def add_side_elements(i, k, arr, some_half):
	while i < len(some_half):
		arr[k] = some_half[i]
		i += 1
		k += 1
	return k
```

## Скриншот

![program](/img/page01.png "program")
---